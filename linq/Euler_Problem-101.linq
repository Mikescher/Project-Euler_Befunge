<Query Kind="Program" />

/*
If we are presented with the first k terms of a 
sequence it is impossible to say with certainty the value of the next term, 
as there are infinitely many polynomial functions that can model the sequence.

As an example, let us consider the sequence of cube numbers. 
This is defined by the generating function,

~~~
u_n = n^3: 1, 8, 27, 64, 125, 216, ...
~~~

Suppose we were only given the first two terms of this sequence.
Working on the principle that "simple is best" we should assume a linear 
relationship and predict the next term to be 15 (common difference 7).
Even if we were presented with the first three terms, by the same 
principle of simplicity, a quadratic relationship should be assumed.

We shall define `OP(k, n)` to be the nth term of the optimum polynomial 
generating function for the first k terms of a sequence.
It should be clear that `OP(k, n)` will accurately generate the terms 
of the sequence for `n <= k`, and potentially the first incorrect term (FIT) 
will be `OP(k, k+1)`; in which case we shall call it a bad OP (BOP).

As a basis, if we were only given the first term of sequence, 
it would be most sensible to assume constancy; that is, for `n >= 2`, `OP(1, n) = u_1`.

Hence we obtain the following OPs for the cubic sequence:

~~~
OP(1, n) = 1            1,     **1**, 1,      1,           ...
OP(2, n) = 7n−6         1,     8,     **15**,              ...
OP(3, n) = 6n^2−11n+6   1,     8,     27,   **58**,        ...
OP(4, n) = n^3          1,     8,     27,     64,     125, ...
~~~

Clearly no BOPs exist for `k >= 4`.

By considering the sum of FITs generated by the BOPs (indicated in **red** above), 
we obtain `1 + 15 + 58 = 74`.

Consider the following tenth degree polynomial generating function:

~~~
un = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10
~~~

Find the sum of FITs for the BOPs.
*/

// https://projecteuler.net/problem=101

// = 37.076.114.526
// sum(FIT) = 37076114526

readonly bool DMP_LIN_EQ = false;

int[] Func = new int[] { +1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1 };
//int[] Func = new int[] { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };

void Main()
{
	Solve();


	//List<Tuple<long[], long>> eq = new List<System.Tuple<long[], long>>(); // 9*x*x - 17*x + 1
	//eq.Add(Tuple.Create(new long[] { 1, 0, 0 }, 1L));
	//eq.Add(Tuple.Create(new long[] { 1, 1, 1 }, -7L));
	//eq.Add(Tuple.Create(new long[] { 1, 2, 4 }, 3L));
	//SolveLinEq(eq).Dump();;
}

void Solve()
{
	long fitsum = 0;

	var seq = Enumerable.Range(1, 11).Select(n => F10D(n, Func)).ToArray();

	$"Full sequence: [{string.Join("; ", seq)}]".Dump();
	"".Dump();
	
	for (int k = 1; ; k++)
	{
		var func_guess = GuessOP(seq.Take(k).ToArray());
		var seq_guess = Enumerable.Range(1, 11).Select(n => F10D(n, func_guess)).ToArray();
		$"Guessing for sequence [{string.Join("; ", seq.Take(k).ToArray())}]".Dump();
		$"Guess OP({k}, n) = {FmtFunc(func_guess)}".Dump();
		$"Guess Result = [{string.Join("; ", seq_guess)}]".Dump();
		//$"Real  Result = [{string.Join("; ", Enumerable.Range(1, 11).Select(n => F10D(n, Func)))}]".Dump();
		
		bool bop = false;
		for (int n = 0; n < 11; n++)
		{
			var guess = seq_guess[n];
			var real = seq[n];
			if (guess != real)
			{
				fitsum += guess;
				$"FIT: OP({k}, {n+1}) = {guess}".Dump();
				bop = true;
				break;
			}
		}
		$"".Dump();
		if (!bop)
		{
			$"Guess fully correct - terminate".Dump();
			$"sum(FIT) = {fitsum}".Dump();
			return;
		}
	}
}

long P(int n, int e) => (long)Math.Pow(n, e); // = n^e

long F10D(int n, params int[] v)//Function of 10th degree
{
	return
		v[0] * P(n, 0) +
		v[1] * P(n, 1) +
		v[2] * P(n, 2) +
		v[3] * P(n, 3) +
		v[4] * P(n, 4) +
		v[5] * P(n, 5) +
		v[6] * P(n, 6) +
		v[7] * P(n, 7) +
		v[8] * P(n, 8) +
		v[9] * P(n, 9) +
		v[10] * P(n, 10);
}

IEnumerable LRange(long start, long end)
{
	for (var i = start; i < end-start; i++) yield return i;
}

string FmtFunc(int[] v)
{
	var xx = v
		.Select((p, i) => new {Val = p, Idx = i})
		.Where(p => p.Val != 0)
		.Select(p => $"{p.Val} * n^{p.Idx}");
	
	return string.Join(" + ", xx);
}

int[] GuessOP(long[] seq)
{
	List<Tuple<long[], long>> eq = new List<System.Tuple<long[], long>>();
	
	for (int i = 0; i < seq.Length; i++)
	{
		long[] dat = Enumerable.Range(0, seq.Length).Select(p => P(i+1, p)).ToArray();
		long res = seq[i];
		
		eq.Add(Tuple.Create(dat, res));
	}
	
	var rr = SolveLinEq(eq).ToList();
	while (rr.Count < 11) rr.Add(0);
	return rr.ToArray();
}

int[] SolveLinEq(List<Tuple<long[], long>> eq)
{
	long[][] equations = eq.Select(e => e.Item1).ToArray();
	long[] solutions = eq.Select(e => e.Item2).ToArray();

	if (equations.Length != equations[0].Length) throw new Exception("s");

	if (DMP_LIN_EQ) FmtLinEq(equations, solutions).Dump();
	
	// [Step 1] Forward Elimination
	for (int s = 0; s < solutions.Length - 1; s++)
	{
		for (int i = s+1; i < solutions.Length; i++)
		{
			// e[i] = e[i] - e[s] // and cancel f_[s]                  

			var f_s = equations[s][s]; // [row][col]
			var f_i = equations[i][s]; // [row][col]

			if (f_s == 0) { FmtLinEq(equations, solutions).Dump(); throw new Exception("X"); continue;}	
			if (f_i == 0) { continue;}	

			LinMult(ref equations[s], ref solutions[s], f_i);
			LinMult(ref equations[i], ref solutions[i], f_s);

			LinSub(ref equations[i], equations[s], ref solutions[i], solutions[s]);

			Simplify(ref equations[s], ref solutions[s]);
			Simplify(ref equations[i], ref solutions[i]);

			if (DMP_LIN_EQ) FmtLinEq(equations, solutions).Dump();
		}
	}
	
	if (DMP_LIN_EQ) FmtLinEq(equations, solutions).Dump();

	// [Step 2] Back substitution
	for (int s = solutions.Length - 2; s >= 0; s--)
	{
		for (int i = s + 1; i < solutions.Length; i++)
		{
			// e[s] = e[s] - e[i] // and cancel f_[i]  
			
			var f_s = equations[s][i]; // [row][col]
			var f_i = equations[i][i]; // [row][col]

			if (f_s == 0) { continue;}			
			if (f_i == 0) { FmtLinEq(equations, solutions).Dump(); throw new Exception("X"); continue;}	

			LinMult(ref equations[s], ref solutions[s], f_i);
			LinMult(ref equations[i], ref solutions[i], f_s);

			LinSub(ref equations[s], equations[i], ref solutions[s], solutions[i]);

			Simplify(ref equations[s], ref solutions[s]);
			Simplify(ref equations[i], ref solutions[i]);
		}

		if (DMP_LIN_EQ) FmtLinEq(equations, solutions).Dump();
	}

	// [Step 3] Finish
	for (int i = 0; i < equations.Length; i++)
	{
		if (equations[i][i] < 0) 
		LinMult(ref equations[i], ref solutions[i], -1);
	}

	for (int s = 0; s < equations.Length; s++)
	{
		for (int i = 0; i < equations.Length; i++)
		{
			if (equations[s][i] != (s == i ? 1 : 0))
			{
				FmtLinEq(equations, solutions).Dump();
				throw new Exception("asd");
			}
		}
	}
	
	return solutions.Select(i => (int)i).ToArray();
}

void Simplify(ref long[] a, ref long s)
{
	long d = GCD(GCD(a), s);
	for (int i = 0; i < a.Length; i++) a[i] = a[i] / d;
	s = s / d;
}

void LinSub(ref long[] a, long[] b, ref long sa, long sb)
{
	for (int i = 0; i < a.Length; i++) a[i] = a[i] - b[i];
	sa = sa - sb;
}

void LinMult(ref long[] eq, ref long sol, long mult)
{
	for (int i = 0; i < eq.Length; i++) eq[i] *= mult; 
	sol *= mult;
}

static long GCD(long[] numbers)
{
	return numbers.Aggregate(GCD);
}

static long GCD(long a, long b)
{
	return b == 0 ? a : GCD(b, a % b);
}

string FmtLinEq(long[][] equations, long[] solutions)
{
	StringBuilder b = new StringBuilder();
	for (int i = 0; i < solutions.Length; i++)
	{
		b.AppendLine(FmtLinEq(equations[i], solutions[i]));
	}
	return b.ToString();
}

string FmtLinEq(long[] equation, long solutions)
{
	return "["+string.Join("; ", equation.Select(e => $"{e, -3}")) + "] = " + solutions;
}